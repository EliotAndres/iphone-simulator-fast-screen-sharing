<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>iOS Simulator Stream</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0d0d0d;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #fff;
    }
    #status-bar {
      position: fixed;
      top: 16px; left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 20px;
      padding: 6px 16px;
      font-size: 13px;
      display: flex; align-items: center; gap: 8px;
      z-index: 10;
      backdrop-filter: blur(8px);
    }
    #status-dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: #888; flex-shrink: 0; transition: background 0.3s;
    }
    #status-dot.connecting { background: #f0a500; }
    #status-dot.streaming  { background: #30d158; }
    #status-dot.error      { background: #ff453a; }
    video {
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;
      border-radius: 12px;
      box-shadow: 0 24px 80px rgba(0,0,0,0.6);
      display: block;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }
    #settings-btn {
      position: fixed;
      top: 16px; left: 16px;
      width: 36px; height: 36px;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      z-index: 10;
      backdrop-filter: blur(8px);
      transition: background 0.2s;
    }
    #settings-btn:hover { background: rgba(255,255,255,0.15); }
    #settings-btn svg { width: 18px; height: 18px; fill: #fff; opacity: 0.85; }
    #settings-menu {
      position: fixed;
      top: 60px; left: 16px;
      background: rgba(30,30,30,0.95);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 4px 0;
      min-width: 140px;
      z-index: 10;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      display: none;
    }
    #settings-menu.open { display: block; }
    .menu-item {
      display: flex; align-items: center; gap: 10px;
      padding: 9px 14px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 6px;
      margin: 2px 4px;
      transition: background 0.15s;
    }
    .menu-item:hover { background: rgba(255,255,255,0.1); }
    .menu-item svg { width: 16px; height: 16px; fill: #fff; opacity: 0.7; flex-shrink: 0; }
  </style>
</head>
<body>
  <div id="status-bar">
    <div id="status-dot" class="connecting"></div>
    <span id="status-text">Connecting...</span>
  </div>

  <button id="settings-btn" title="Settings">
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5m7.43-2.92c.04-.34.07-.69.07-1.08s-.03-.74-.07-1.08l2.32-1.82c.21-.16.27-.46.13-.7l-2.2-3.81c-.14-.23-.43-.31-.67-.23l-2.73 1.1c-.57-.44-1.18-.8-1.85-1.08L14.92 2.1c-.04-.26-.27-.46-.54-.46h-4.4c-.27 0-.5.2-.54.46l-.42 2.88c-.67.28-1.29.64-1.85 1.08L4.44 6.06c-.24-.09-.53 0-.67.23L1.57 10.1c-.14.24-.08.54.13.7l2.32 1.82c-.04.34-.06.7-.06 1.08s.02.74.06 1.08L1.7 16.6c-.21.16-.27.46-.13.7l2.2 3.81c.14.23.43.31.67.23l2.73-1.1c.57.44 1.18.8 1.85 1.08l.42 2.88c.04.26.27.46.54.46h4.4c.27 0 .5-.2.54-.46l.42-2.88c.67-.28 1.28-.64 1.85-1.08l2.73 1.1c.24.09.53 0 .67-.23l2.2-3.81c.14-.24.08-.54-.13-.7l-2.32-1.82z"/>
    </svg>
  </button>

  <div id="settings-menu">
    <div class="menu-item" id="menu-home">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
      </svg>
      Home
    </div>
  </div>

  <video id="video" autoplay playsinline muted></video>

  <script>
    const video = document.getElementById('video');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const settingsBtn = document.getElementById('settings-btn');
    const settingsMenu = document.getElementById('settings-menu');
    // ─── Timing helpers ───────────────────────────────────────────────────────
    const T0 = performance.now();
    function ts() { return ((performance.now() - T0) / 1000).toFixed(3) + 's'; }
    function log(label, ...args) { console.log(`[${ts()}] ${label}`, ...args); }

    // ─── Environment ──────────────────────────────────────────────────────────
    log('ENV browser', navigator.userAgent);
    log('ENV origin', location.origin);
    log('ENV RTCPeerConnection', typeof RTCPeerConnection);
    log('ENV requestVideoFrameCallback', typeof video.requestVideoFrameCallback);
    log('ENV jitterBufferTarget (RTCRtpReceiver)', 'jitterBufferTarget' in RTCRtpReceiver.prototype ? 'supported' : 'NOT supported');

    // ─── SDP codec parser ─────────────────────────────────────────────────────
    function parseSdpCodecs(sdp) {
      const codecs = [];
      const lines = sdp.split('\n');
      const payloadMap = {};
      lines.forEach(l => {
        const m = l.match(/^a=rtpmap:(\d+)\s+(\S+)/);
        if (m) payloadMap[m[1]] = m[2];
      });
      lines.forEach(l => {
        const m = l.match(/^a=fmtp:(\d+)\s+(.+)/);
        if (m && payloadMap[m[1]]) codecs.push(`${payloadMap[m[1]]} [${m[2].trim()}]`);
      });
      if (codecs.length === 0) Object.values(payloadMap).forEach(v => codecs.push(v));
      return codecs;
    }

    function setStatus(state, text) {
      statusDot.className = state;
      statusText.textContent = text;
    }

    // Settings menu toggle
    settingsBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      settingsMenu.classList.toggle('open');
    });
    document.addEventListener('click', () => settingsMenu.classList.remove('open'));

    function sendCommand(type) {
      if (touchChannel.readyState !== 'open') return;
      touchChannel.send(JSON.stringify({ type }));
    }

    document.getElementById('menu-home').addEventListener('click', () => {
      sendCommand('home');
      settingsMenu.classList.remove('open');
    });

    const pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    // ─── ICE / connection state logging ───────────────────────────────────────
    pc.onicecandidate = (event) => {
      if (event.candidate && event.candidate.candidate) {
        const c = event.candidate.candidate;
        const isMdns = c.includes('.local');
        const typeMatch = c.match(/typ (\w+)/);
        const protoMatch = c.match(/(\w+) \d+ \w+ \d+ /);
        log('ICE local candidate',
          `type=${typeMatch?.[1] ?? '?'}`,
          `proto=${event.candidate.protocol ?? '?'}`,
          isMdns ? '⚠️ mDNS (.local)' : '',
          c.slice(0, 80));
        ws.send(JSON.stringify({
          type: 'ice-candidate',
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }));
      } else if (!event.candidate) {
        log('ICE gathering complete');
      }
    };

    pc.onicegatheringstatechange = () => log('ICE gathering state', pc.iceGatheringState);
    pc.oniceconnectionstatechange = () => log('ICE connection state', pc.iceConnectionState);
    pc.onsignalingstatechange = () => log('Signaling state', pc.signalingState);
    pc.onconnectionstatechange = () => {
      log('Peer connection state', pc.connectionState);
      if (pc.connectionState === 'failed') setStatus('error', 'Connection failed');
      if (pc.connectionState === 'connected') {
        logSelectedCandidatePair();
        startStatsPolling();
      }
    };

    async function logSelectedCandidatePair() {
      try {
        const stats = await pc.getStats();
        stats.forEach(r => {
          if (r.type === 'candidate-pair' && r.nominated) {
            const local  = stats.get(r.localCandidateId);
            const remote = stats.get(r.remoteCandidateId);
            log('ICE selected pair',
              `local=${local?.candidateType}/${local?.protocol} ${local?.address ?? local?.ip ?? '?'}:${local?.port ?? '?'}`,
              `remote=${remote?.candidateType}/${remote?.protocol} ${remote?.address ?? remote?.ip ?? '?'}:${remote?.port ?? '?'}`,
              `RTT=${r.currentRoundTripTime != null ? (r.currentRoundTripTime * 1000).toFixed(1) + 'ms' : '?'}`
            );
          }
        });
      } catch(e) { log('ICE getStats error', e.message); }
    }

    // Periodic stats: jitter buffer, codec, RTT, packet loss
    let statsInterval = null;
    let prevStats = {};
    function startStatsPolling() {
      if (statsInterval) return;
      statsInterval = setInterval(async () => {
        try {
          const stats = await pc.getStats();
          const codecMap = {};
          stats.forEach(r => { if (r.type === 'codec') codecMap[r.id] = r; });

          stats.forEach(r => {
            if (r.type === 'inbound-rtp' && r.kind === 'video') {
              const codec = codecMap[r.codecId];
              const jbDelay = r.jitterBufferDelay != null && r.jitterBufferEmittedCount
                ? (r.jitterBufferDelay / r.jitterBufferEmittedCount * 1000).toFixed(1) + 'ms'
                : '?';
              const prev = prevStats[r.id] || {};
              const fps = prev.framesDecoded != null
                ? ((r.framesDecoded - prev.framesDecoded) / 2).toFixed(1) + 'fps'
                : '?';
              log('STATS inbound-rtp',
                `codec=${codec?.mimeType ?? '?'}`,
                `jitterBufDelay=${jbDelay}`,
                `jitter=${r.jitter != null ? (r.jitter * 1000).toFixed(1) + 'ms' : '?'}`,
                `lost=${r.packetsLost ?? '?'}`,
                `fps≈${fps}`,
                `framesDropped=${r.framesDropped ?? '?'}`,
                `nackCount=${r.nackCount ?? '?'}`
              );
              prevStats[r.id] = { framesDecoded: r.framesDecoded };
            }
            if (r.type === 'candidate-pair' && r.nominated) {
              log('STATS candidate-pair',
                `RTT=${r.currentRoundTripTime != null ? (r.currentRoundTripTime * 1000).toFixed(1) + 'ms' : '?'}`,
                `available bw=${r.availableOutgoingBitrate != null ? (r.availableOutgoingBitrate / 1000).toFixed(0) + 'kbps' : '?'}`
              );
            }
          });
        } catch(e) { log('STATS error', e.message); }
      }, 2000);
    }

    // Data channel for sending touch/mouse events to the streamer
    const touchChannel = pc.createDataChannel('touch', { ordered: true });
    touchChannel.onopen = () => log('Touch data channel open');
    touchChannel.onclose = () => log('Touch data channel closed');

    function sendTouch(type, clientX, clientY) {
      if (touchChannel.readyState !== 'open') return;
      const rect = video.getBoundingClientRect();
      // Map client coordinates to normalized 0..1 within the video's rendered area,
      // accounting for object-fit:contain letterboxing.
      const videoW = video.videoWidth;
      const videoH = video.videoHeight;
      if (!videoW || !videoH) return;

      const videoAspect = videoW / videoH;
      const boxAspect = rect.width / rect.height;
      let renderW, renderH, offsetX, offsetY;
      if (videoAspect > boxAspect) {
        renderW = rect.width;
        renderH = rect.width / videoAspect;
        offsetX = 0;
        offsetY = (rect.height - renderH) / 2;
      } else {
        renderH = rect.height;
        renderW = rect.height * videoAspect;
        offsetX = (rect.width - renderW) / 2;
        offsetY = 0;
      }

      const x = (clientX - rect.left - offsetX) / renderW;
      const y = (clientY - rect.top - offsetY) / renderH;
      if (x < 0 || x > 1 || y < 0 || y > 1) return;
      touchChannel.send(JSON.stringify({ type, x, y }));
    }

    // Throttle move events to one per animation frame
    let pendingMove = null;
    let moveRafPending = false;
    function queueMove(clientX, clientY) {
      pendingMove = { clientX, clientY };
      if (!moveRafPending) {
        moveRafPending = true;
        requestAnimationFrame(() => {
          moveRafPending = false;
          if (pendingMove) {
            sendTouch('move', pendingMove.clientX, pendingMove.clientY);
            pendingMove = null;
          }
        });
      }
    }

    // Mouse events
    video.addEventListener('mousedown', (e) => { e.preventDefault(); sendTouch('down', e.clientX, e.clientY); });
    video.addEventListener('mousemove', (e) => { if (e.buttons & 1) queueMove(e.clientX, e.clientY); });
    video.addEventListener('mouseup',   (e) => { sendTouch('up', e.clientX, e.clientY); });

    // Touch events (mobile / tablet)
    video.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      sendTouch('down', t.clientX, t.clientY);
    });
    video.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      queueMove(t.clientX, t.clientY);
    });
    video.addEventListener('touchend', (e) => {
      e.preventDefault();
      const t = e.changedTouches[0];
      sendTouch('up', t.clientX, t.clientY);
    });

    // ─── Video element lifecycle logging ──────────────────────────────────────
    ['loadstart','loadedmetadata','loadeddata','canplay','canplaythrough','waiting','stalled'].forEach(evt => {
      video.addEventListener(evt, () => log(`video:${evt}`,
        `currentTime=${video.currentTime.toFixed(3)}`,
        `readyState=${video.readyState}`,
        `buffered ranges=${video.buffered.length}`,
        video.buffered.length ? `[0..${video.buffered.end(video.buffered.length-1).toFixed(3)}]` : ''
      ));
    });
    video.addEventListener('loadedmetadata', () =>
      log('video:resolution', `${video.videoWidth}x${video.videoHeight}`)
    );
    video.onerror = (e) => { log('video:error', video.error); setStatus('error', 'Video error'); };

    video.addEventListener('playing', () => {
      setStatus('streaming', 'Streaming');
      const bufferedAtPlay = video.buffered.length > 0
        ? video.buffered.end(video.buffered.length - 1).toFixed(3)
        : 'none';
      log('video:playing', `currentTime=${video.currentTime.toFixed(3)}`, `buffered end=${bufferedAtPlay}s`);
    });

    pc.ontrack = (event) => {
      log('ontrack', `kind=${event.track.kind}`, `id=${event.track.id}`, `streams=${event.streams.length}`);

      // Log receiver capabilities
      if (event.receiver?.getParameters) {
        const params = event.receiver.getParameters();
        log('ontrack receiver codecs', params.codecs?.map(c => `${c.mimeType}/${c.clockRate}`).join(', ') || 'none');
      }

      // Safari bug: event.streams may be empty even when a track arrives.
      let stream = (event.streams && event.streams[0]) || null;
      if (!stream) { stream = new MediaStream([event.track]); log('ontrack built MediaStream manually'); }

      video.srcObject = stream;
      video.play().catch((e) => {
        log('video.play() blocked', e.message, '— waiting for user gesture');
        setStatus('connecting', 'Tap to play');
        document.body.addEventListener('click', () => video.play(), { once: true });
      });
    };

    pc.onicecandidate = (event) => {
      if (event.candidate && event.candidate.candidate) {
        ws.send(JSON.stringify({
          type: 'ice-candidate',
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }));
      }
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === 'failed') setStatus('error', 'Connection failed');
    };

    const wsProto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(`${wsProto}//${location.host}/ws`);
    log('WS connecting to', `${wsProto}//${location.host}/ws`);

    ws.onopen = () => {
      log('WS open');
      ws.send(JSON.stringify({ type: 'register', role: 'viewer' }));
      setStatus('connecting', 'Waiting for streamer...');
    };

    ws.onmessage = async (event) => {
      let msg;
      try { msg = JSON.parse(event.data); } catch { return; }
      log('WS recv', msg.type);

      if (msg.type === 'streamer-ready') {
        setStatus('connecting', 'Negotiating...');
        await createAndSendOffer();
      } else if (msg.type === 'answer') {
        try {
          log('SDP answer codecs', parseSdpCodecs(msg.sdp));
          await pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });
          log('setRemoteDescription done');
        } catch(e) { log('setRemoteDescription failed', e.message); setStatus('error', 'Negotiation failed'); }
      } else if (msg.type === 'ice-candidate') {
        if (!msg.candidate) return;
        const isMdns = msg.candidate.includes('.local');
        const typeMatch = msg.candidate.match(/typ (\w+)/);
        log('ICE remote candidate', `type=${typeMatch?.[1] ?? '?'}`, isMdns ? '⚠️ mDNS' : '', msg.candidate.slice(0, 80));
        try {
          await pc.addIceCandidate({ candidate: msg.candidate, sdpMLineIndex: msg.sdpMLineIndex, sdpMid: msg.sdpMid });
        } catch { /* ignore stale candidates */ }
      } else if (msg.type === 'streamer-disconnected') {
        log('Streamer disconnected');
        setStatus('error', 'Streamer disconnected');
        video.srcObject = null;
      }
    };

    ws.onerror = (e) => { log('WS error', e); setStatus('error', 'Signaling unreachable'); };
    ws.onclose = (e) => { log('WS closed', `code=${e.code}`); setStatus('error', 'WS closed'); };

    async function createAndSendOffer() {
      try {
        // addTransceiver is the correct Unified Plan approach for recvonly video.
        // offerToReceiveVideo is a legacy Plan-B hint that Safari ignores.
        if (pc.getTransceivers().length === 0) {
          const transceiver = pc.addTransceiver('video', { direction: 'recvonly' });

          // Safari lists H.264 High Profile (640c1f) first in its offer.
          // The Swift VideoToolbox encoder picks that profile and takes ~7s to
          // produce the first IDR keyframe in High Profile mode, causing the
          // massive startup delay seen only in Safari.
          // Firefox lists Baseline (42e01f) first → Swift picks Baseline → fast.
          // Fix: use setCodecPreferences to exclude High Profile so both browsers
          // negotiate Baseline and get the same ~700ms startup time.
          const caps = RTCRtpReceiver.getCapabilities?.('video');
          if (caps?.codecs && transceiver.setCodecPreferences) {
            const filtered = caps.codecs.filter(c => {
              if (c.mimeType !== 'video/H264') return true;
              // Drop any H.264 profile where the first nibble is 6x (High, High 4:2:2, etc.)
              const m = c.sdpFmtpLine?.match(/profile-level-id=([0-9a-f]{6})/i);
              if (m && parseInt(m[1].slice(0, 2), 16) >= 0x60) return false;
              return true;
            });
            if (filtered.length > 0) {
              transceiver.setCodecPreferences(filtered);
              log('codec prefs: excluded H264 High Profile (640c1f)',
                filtered.filter(c => c.mimeType === 'video/H264').map(c =>
                  c.sdpFmtpLine?.match(/profile-level-id=\w+/)?.[0] ?? c.mimeType
                )
              );
            }
          } else {
            log('codec prefs: setCodecPreferences not available, High Profile may be negotiated');
          }
        }
        const offer = await pc.createOffer();
        log('SDP offer codecs', parseSdpCodecs(offer.sdp));
        await pc.setLocalDescription(offer);
        log('offer sent');
        ws.send(JSON.stringify({ type: 'offer', sdp: offer.sdp }));
      } catch(e) {
        log('createOffer failed', e.message);
        setStatus('error', 'Offer failed');
      }
    }
  </script>
</body>
</html>
