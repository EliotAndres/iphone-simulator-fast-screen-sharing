<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>iOS Simulator Stream</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0d0d0d;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #fff;
    }
    #status-bar {
      position: fixed;
      top: 16px; left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 20px;
      padding: 6px 16px;
      font-size: 13px;
      display: flex; align-items: center; gap: 8px;
      z-index: 10;
      backdrop-filter: blur(8px);
    }
    #status-dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: #888; flex-shrink: 0; transition: background 0.3s;
    }
    #status-dot.connecting { background: #f0a500; }
    #status-dot.streaming  { background: #30d158; }
    #status-dot.error      { background: #ff453a; }
    video {
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;
      border-radius: 12px;
      box-shadow: 0 24px 80px rgba(0,0,0,0.6);
      display: block;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }
    #settings-btn {
      position: fixed;
      top: 16px; left: 16px;
      width: 36px; height: 36px;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      z-index: 10;
      backdrop-filter: blur(8px);
      transition: background 0.2s;
    }
    #settings-btn:hover { background: rgba(255,255,255,0.15); }
    #settings-btn svg { width: 18px; height: 18px; fill: #fff; opacity: 0.85; }
    #settings-menu {
      position: fixed;
      top: 60px; left: 16px;
      background: rgba(30,30,30,0.95);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 4px 0;
      min-width: 140px;
      z-index: 10;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      display: none;
    }
    #settings-menu.open { display: block; }
    .menu-item {
      display: flex; align-items: center; gap: 10px;
      padding: 9px 14px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 6px;
      margin: 2px 4px;
      transition: background 0.15s;
    }
    .menu-item:hover { background: rgba(255,255,255,0.1); }
    .menu-item svg { width: 16px; height: 16px; fill: #fff; opacity: 0.7; flex-shrink: 0; }
    #stats-overlay {
      position: fixed;
      bottom: 16px; right: 16px;
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 12px;
      font-family: 'SF Mono', 'Menlo', monospace;
      line-height: 1.6;
      z-index: 10;
      backdrop-filter: blur(8px);
      color: rgba(255,255,255,0.85);
      display: none;
    }
    #stats-overlay.visible { display: block; }
    #stats-overlay .stat-row { display: flex; justify-content: space-between; gap: 16px; }
    #stats-overlay .stat-label { color: rgba(255,255,255,0.45); }
    #stats-overlay .stat-value { text-align: right; }
    #stats-overlay .lag-ok   { color: #30d158; }
    #stats-overlay .lag-warn { color: #f0a500; }
    #stats-overlay .lag-bad  { color: #ff453a; }
  </style>
</head>
<body>
  <div id="status-bar">
    <div id="status-dot" class="connecting"></div>
    <span id="status-text">Connecting...</span>
  </div>

  <button id="settings-btn" title="Settings">
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5m7.43-2.92c.04-.34.07-.69.07-1.08s-.03-.74-.07-1.08l2.32-1.82c.21-.16.27-.46.13-.7l-2.2-3.81c-.14-.23-.43-.31-.67-.23l-2.73 1.1c-.57-.44-1.18-.8-1.85-1.08L14.92 2.1c-.04-.26-.27-.46-.54-.46h-4.4c-.27 0-.5.2-.54.46l-.42 2.88c-.67.28-1.29.64-1.85 1.08L4.44 6.06c-.24-.09-.53 0-.67.23L1.57 10.1c-.14.24-.08.54.13.7l2.32 1.82c-.04.34-.06.7-.06 1.08s.02.74.06 1.08L1.7 16.6c-.21.16-.27.46-.13.7l2.2 3.81c.14.23.43.31.67.23l2.73-1.1c.57.44 1.18.8 1.85 1.08l.42 2.88c.04.26.27.46.54.46h4.4c.27 0 .5-.2.54-.46l.42-2.88c.67-.28 1.28-.64 1.85-1.08l2.73 1.1c.24.09.53 0 .67-.23l2.2-3.81c.14-.24.08-.54-.13-.7l-2.32-1.82z"/>
    </svg>
  </button>

  <div id="settings-menu">
    <div class="menu-item" id="menu-home">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
      </svg>
      Home
    </div>
  </div>

  <video id="video" autoplay playsinline muted></video>

  <div id="stats-overlay">
    <div class="stat-row"><span class="stat-label">wall lag</span><span class="stat-value" id="stat-wall">—</span></div>
    <div class="stat-row"><span class="stat-label">buffered lag</span><span class="stat-value" id="stat-buf">—</span></div>
    <div class="stat-row"><span class="stat-label">seeks</span><span class="stat-value" id="stat-seeks">0</span></div>
    <div class="stat-row"><span class="stat-label">hidden lag</span><span class="stat-value" id="stat-hidden">0</span></div>
  </div>

  <script>
    const video = document.getElementById('video');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const settingsBtn = document.getElementById('settings-btn');
    const settingsMenu = document.getElementById('settings-menu');
    const statsOverlay = document.getElementById('stats-overlay');
    const statWall = document.getElementById('stat-wall');
    const statBuf = document.getElementById('stat-buf');
    const statSeeks = document.getElementById('stat-seeks');
    const statHidden = document.getElementById('stat-hidden');
    let seekCount = 0, hiddenCount = 0;

    function lagClass(s) {
      return s < 0.1 ? 'lag-ok' : s < 0.5 ? 'lag-warn' : 'lag-bad';
    }
    function updateStats(wallLag, bufferedLag) {
      statWall.textContent = (wallLag * 1000).toFixed(0) + ' ms';
      statWall.className = 'stat-value ' + lagClass(wallLag);
      statBuf.textContent = (bufferedLag * 1000).toFixed(0) + ' ms';
      statBuf.className = 'stat-value ' + lagClass(bufferedLag);
      statSeeks.textContent = seekCount;
      statHidden.textContent = hiddenCount;
    }

    function setStatus(state, text) {
      statusDot.className = state;
      statusText.textContent = text;
    }

    // Settings menu toggle
    settingsBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      settingsMenu.classList.toggle('open');
    });
    document.addEventListener('click', () => settingsMenu.classList.remove('open'));

    function sendCommand(type) {
      if (touchChannel.readyState !== 'open') return;
      touchChannel.send(JSON.stringify({ type }));
    }

    document.getElementById('menu-home').addEventListener('click', () => {
      sendCommand('home');
      settingsMenu.classList.remove('open');
    });

    const pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    // Data channel for sending touch/mouse events to the streamer
    const touchChannel = pc.createDataChannel('touch', { ordered: true });
    touchChannel.onopen = () => console.log('[Touch] Data channel open');
    touchChannel.onclose = () => console.log('[Touch] Data channel closed');

    function sendTouch(type, clientX, clientY) {
      if (touchChannel.readyState !== 'open') return;
      const rect = video.getBoundingClientRect();
      // Map client coordinates to normalized 0..1 within the video's rendered area,
      // accounting for object-fit:contain letterboxing.
      const videoW = video.videoWidth;
      const videoH = video.videoHeight;
      if (!videoW || !videoH) return;

      const videoAspect = videoW / videoH;
      const boxAspect = rect.width / rect.height;
      let renderW, renderH, offsetX, offsetY;
      if (videoAspect > boxAspect) {
        renderW = rect.width;
        renderH = rect.width / videoAspect;
        offsetX = 0;
        offsetY = (rect.height - renderH) / 2;
      } else {
        renderH = rect.height;
        renderW = rect.height * videoAspect;
        offsetX = (rect.width - renderW) / 2;
        offsetY = 0;
      }

      const x = (clientX - rect.left - offsetX) / renderW;
      const y = (clientY - rect.top - offsetY) / renderH;
      if (x < 0 || x > 1 || y < 0 || y > 1) return;
      touchChannel.send(JSON.stringify({ type, x, y }));
    }

    // Throttle move events to one per animation frame
    let pendingMove = null;
    let moveRafPending = false;
    function queueMove(clientX, clientY) {
      pendingMove = { clientX, clientY };
      if (!moveRafPending) {
        moveRafPending = true;
        requestAnimationFrame(() => {
          moveRafPending = false;
          if (pendingMove) {
            sendTouch('move', pendingMove.clientX, pendingMove.clientY);
            pendingMove = null;
          }
        });
      }
    }

    // Mouse events
    video.addEventListener('mousedown', (e) => { e.preventDefault(); sendTouch('down', e.clientX, e.clientY); });
    video.addEventListener('mousemove', (e) => { if (e.buttons & 1) queueMove(e.clientX, e.clientY); });
    video.addEventListener('mouseup',   (e) => { sendTouch('up', e.clientX, e.clientY); });

    // Touch events (mobile / tablet)
    video.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      sendTouch('down', t.clientX, t.clientY);
    });
    video.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      queueMove(t.clientX, t.clientY);
    });
    video.addEventListener('touchend', (e) => {
      e.preventDefault();
      const t = e.changedTouches[0];
      sendTouch('up', t.clientX, t.clientY);
    });

    video.onerror = () => setStatus('error', 'Video error');

    // Safari problem: during ICE negotiation (slower through a tunnel due to mDNS
    // candidate resolution), frames pile up in the receive buffer before playback
    // starts, resulting in 2-3s of lag from frame 1. AVFoundation also adds its own
    // buffer on top of the WebRTC jitter buffer.
    //
    // Fix: seek to the live edge immediately on 'playing', then use wall-clock drift
    // detection + seeking to keep up. playbackRate is spec-prohibited for live
    // MediaStream and silently ignored by Safari, so we never use it.
    let liveEdgePursuit = null;
    let refWallTime = null;
    let refVideoTime = null;

    function seekToLiveEdge(reason) {
      if (video.buffered.length === 0) return;
      const liveEdge = video.buffered.end(video.buffered.length - 1);
      const bufferedLag = liveEdge - video.currentTime;
      if (bufferedLag > 0.05) {
        video.currentTime = liveEdge;
        seekCount++;
        statSeeks.textContent = seekCount;
      }
      // Re-anchor wall-clock reference after seek
      refWallTime = performance.now();
      refVideoTime = video.currentTime;
    }

    function startLiveEdgePursuit() {
      if (liveEdgePursuit) return;
      refWallTime = null;
      refVideoTime = null;
      function step() {
        liveEdgePursuit = video.requestVideoFrameCallback(step);
        if (refWallTime === null) {
          refWallTime = performance.now();
          refVideoTime = video.currentTime;
          return;
        }
        const expectedVideoTime = refVideoTime + (performance.now() - refWallTime) / 1000;
        const wallLag = expectedVideoTime - video.currentTime;
        const bufferedLag = video.buffered.length > 0
          ? video.buffered.end(video.buffered.length - 1) - video.currentTime
          : 0;
        updateStats(wallLag, bufferedLag);
        if (wallLag > 0.3) {
          if (bufferedLag > 0.05) {
            // Lag is visible to JS — seek directly
            seekToLiveEdge(`wall lag ${wallLag.toFixed(2)}s`);
          } else {
            // Wall-clock says we're behind but video.buffered doesn't see it:
            // AVFoundation internal buffer. Re-anchor so we don't spam seeks.
            hiddenCount++;
            statHidden.textContent = hiddenCount;
            refWallTime = performance.now();
            refVideoTime = video.currentTime;
          }
        }
      }
      liveEdgePursuit = video.requestVideoFrameCallback(step);
    }
    function stopLiveEdgePursuit() {
      if (liveEdgePursuit) { video.cancelVideoFrameCallback(liveEdgePursuit); liveEdgePursuit = null; }
      statsOverlay.classList.remove('visible');
    }

    video.addEventListener('playing', () => {
      setStatus('streaming', 'Streaming');
      statsOverlay.classList.add('visible');
      seekCount = 0; hiddenCount = 0;
      // Drain any frames that accumulated during ICE negotiation before seeking
      // back to live.  A short delay lets Safari populate video.buffered first.
      setTimeout(() => seekToLiveEdge('initial play'), 200);
      startLiveEdgePursuit();
    });
    video.addEventListener('pause',   stopLiveEdgePursuit);
    video.addEventListener('ended',   stopLiveEdgePursuit);

    pc.ontrack = (event) => {
      // Minimize jitter buffer delay (Safari 16+, Chrome 107+).
      // Safari defaults to ~150-200ms; setting 0 tells it to play as soon as possible.
      if (event.receiver?.jitterBufferTarget !== undefined) {
        event.receiver.jitterBufferTarget = 0;
      }

      // Safari bug: event.streams may be empty even when a track arrives.
      // Work around by building a MediaStream manually from the track.
      let stream = (event.streams && event.streams[0]) || null;
      if (!stream) stream = new MediaStream([event.track]);

      video.srcObject = stream;
      video.play().catch(() => {
        setStatus('connecting', 'Tap to play');
        document.body.addEventListener('click', () => video.play(), { once: true });
      });
    };

    pc.onicecandidate = (event) => {
      if (event.candidate && event.candidate.candidate) {
        ws.send(JSON.stringify({
          type: 'ice-candidate',
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }));
      }
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === 'failed') setStatus('error', 'Connection failed');
    };

    const wsProto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(`${wsProto}//${location.host}/ws`);

    ws.onopen = () => {
      ws.send(JSON.stringify({ type: 'register', role: 'viewer' }));
      setStatus('connecting', 'Waiting for streamer...');
    };

    ws.onmessage = async (event) => {
      let msg;
      try { msg = JSON.parse(event.data); } catch { return; }

      if (msg.type === 'streamer-ready') {
        setStatus('connecting', 'Negotiating...');
        await createAndSendOffer();
      } else if (msg.type === 'answer') {
        try {
          await pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });
        } catch { setStatus('error', 'Negotiation failed'); }
      } else if (msg.type === 'ice-candidate') {
        if (!msg.candidate) return;
        try {
          await pc.addIceCandidate({ candidate: msg.candidate, sdpMLineIndex: msg.sdpMLineIndex, sdpMid: msg.sdpMid });
        } catch { /* ignore stale candidates */ }
      } else if (msg.type === 'streamer-disconnected') {
        setStatus('error', 'Streamer disconnected');
        video.srcObject = null;
      }
    };

    ws.onerror = () => setStatus('error', 'Signaling unreachable');
    ws.onclose = () => setStatus('error', 'WS closed');

    async function createAndSendOffer() {
      try {
        // addTransceiver is the correct Unified Plan approach for recvonly video.
        // offerToReceiveVideo is a legacy Plan-B hint that Safari ignores.
        if (pc.getTransceivers().length === 0) {
          pc.addTransceiver('video', { direction: 'recvonly' });
        }
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({ type: 'offer', sdp: offer.sdp }));
      } catch {
        setStatus('error', 'Offer failed');
      }
    }
  </script>
</body>
</html>
