<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>iOS Simulator Stream</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0d0d0d;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      color: #fff;
    }
    #status-bar {
      position: fixed;
      top: 16px; left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 20px;
      padding: 6px 16px;
      font-size: 13px;
      display: flex; align-items: center; gap: 8px;
      z-index: 10;
      backdrop-filter: blur(8px);
    }
    #status-dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: #888; flex-shrink: 0; transition: background 0.3s;
    }
    #status-dot.connecting { background: #f0a500; }
    #status-dot.streaming  { background: #30d158; }
    #status-dot.error      { background: #ff453a; }
    video {
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;
      border-radius: 12px;
      box-shadow: 0 24px 80px rgba(0,0,0,0.6);
      display: block;
    }
  </style>
</head>
<body>
  <div id="status-bar">
    <div id="status-dot" class="connecting"></div>
    <span id="status-text">Connecting...</span>
  </div>
  <video id="video" autoplay playsinline muted></video>

  <script>
    const video = document.getElementById('video');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');

    function setStatus(state, text) {
      statusDot.className = state;
      statusText.textContent = text;
    }

    const pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    video.onplaying = () => setStatus('streaming', 'Streaming');
    video.onerror   = () => setStatus('error', 'Video error');

    pc.ontrack = (event) => {
      // Safari bug: event.streams may be empty even when a track arrives.
      // Work around by building a MediaStream manually from the track.
      let stream = (event.streams && event.streams[0]) || null;
      if (!stream) stream = new MediaStream([event.track]);

      video.srcObject = stream;
      video.play().catch(() => {
        setStatus('connecting', 'Tap to play');
        document.body.addEventListener('click', () => video.play(), { once: true });
      });
    };

    pc.onicecandidate = (event) => {
      if (event.candidate && event.candidate.candidate) {
        ws.send(JSON.stringify({
          type: 'ice-candidate',
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }));
      }
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === 'failed') setStatus('error', 'Connection failed');
    };

    const wsProto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(`${wsProto}//${location.host}/ws`);

    ws.onopen = () => {
      ws.send(JSON.stringify({ type: 'register', role: 'viewer' }));
      setStatus('connecting', 'Waiting for streamer...');
    };

    ws.onmessage = async (event) => {
      let msg;
      try { msg = JSON.parse(event.data); } catch { return; }

      if (msg.type === 'streamer-ready') {
        setStatus('connecting', 'Negotiating...');
        await createAndSendOffer();
      } else if (msg.type === 'answer') {
        try {
          await pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });
        } catch { setStatus('error', 'Negotiation failed'); }
      } else if (msg.type === 'ice-candidate') {
        if (!msg.candidate) return;
        try {
          await pc.addIceCandidate({ candidate: msg.candidate, sdpMLineIndex: msg.sdpMLineIndex, sdpMid: msg.sdpMid });
        } catch { /* ignore stale candidates */ }
      } else if (msg.type === 'streamer-disconnected') {
        setStatus('error', 'Streamer disconnected');
        video.srcObject = null;
      }
    };

    ws.onerror = () => setStatus('error', 'Signaling unreachable');
    ws.onclose = () => setStatus('error', 'WS closed');

    async function createAndSendOffer() {
      try {
        // addTransceiver is the correct Unified Plan approach for recvonly video.
        // offerToReceiveVideo is a legacy Plan-B hint that Safari ignores.
        if (pc.getTransceivers().length === 0) {
          pc.addTransceiver('video', { direction: 'recvonly' });
        }
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({ type: 'offer', sdp: offer.sdp }));
      } catch {
        setStatus('error', 'Offer failed');
      }
    }
  </script>
</body>
</html>
